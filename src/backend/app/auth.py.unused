"""
SE-QPT Authentication System
User registration, login, and JWT token management
"""

from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity, create_refresh_token
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta
import re

from models import db
from models import User

auth_bp = Blueprint('auth', __name__)

def validate_email(email):
    """Validate email format"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

def validate_password(password):
    """Validate password strength - relaxed requirements"""
    if len(password) < 4:
        return False, "Password must be at least 4 characters long"
    return True, "Password is valid"

@auth_bp.route('/register', methods=['POST'])
def register():
    """User registration endpoint"""
    try:
        data = request.get_json()

        # Validate required fields
        required_fields = ['username', 'password', 'first_name', 'last_name']
        for field in required_fields:
            if not data.get(field):
                return {'error': f'{field} is required'}, 400

        username = data['username'].strip()
        email = data.get('email', f'{username}@example.com').strip().lower()
        password = data['password']
        first_name = data['first_name'].strip()
        last_name = data['last_name'].strip()

        # Validate password strength
        is_valid, message = validate_password(password)
        if not is_valid:
            return {'error': message}, 400

        # Check if username already exists
        if User.query.filter_by(username=username).first():
            return {'error': 'Username already exists'}, 400

        # Handle potential email conflicts for auto-generated emails
        original_email = email
        counter = 1
        while User.query.filter_by(email=email).first():
            if original_email.endswith('@example.com'):
                email = f'{username}_{counter}@example.com'
                counter += 1
            else:
                return {'error': 'Email already registered'}, 400

        # Create new user
        user = User(
            username=username,
            email=email,
            first_name=first_name,
            last_name=last_name,
            organization=data.get('organization', ''),
            role=data.get('role', ''),
            user_type=data.get('user_type', 'participant'),
            is_active=True,
            is_verified=False  # Email verification would be implemented here
        )
        user.set_password(password)

        db.session.add(user)
        db.session.commit()

        # Create access token for immediate login
        access_token = create_access_token(
            identity=str(user.id),
            expires_delta=timedelta(hours=24)
        )
        refresh_token = create_refresh_token(identity=str(user.id))

        return {
            'message': 'User registered successfully',
            'user': user.to_dict(),
            'access_token': access_token,
            'refresh_token': refresh_token
        }, 201

    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Registration error: {str(e)}")
        return {'error': 'Registration failed'}, 500

@auth_bp.route('/login', methods=['POST'])
def login():
    """User login endpoint"""
    try:
        data = request.get_json()

        username_or_email = data.get('username_or_email', '').strip()
        password = data.get('password', '')

        if not username_or_email or not password:
            return {'error': 'Username/email and password are required'}, 400

        # Find user by username or email
        user = User.query.filter(
            (User.username == username_or_email) | (User.email == username_or_email.lower())
        ).first()

        if not user:
            return {'error': 'Invalid credentials'}, 401

        if not user.is_active:
            return {'error': 'Account is deactivated'}, 401

        if not user.check_password(password):
            return {'error': 'Invalid credentials'}, 401

        # Update last login
        user.last_login = datetime.utcnow()
        db.session.commit()

        # Create tokens
        access_token = create_access_token(
            identity=str(user.id),
            expires_delta=timedelta(hours=24)
        )
        refresh_token = create_refresh_token(identity=str(user.id))

        return {
            'message': 'Login successful',
            'user': user.to_dict(),
            'access_token': access_token,
            'refresh_token': refresh_token
        }

    except Exception as e:
        current_app.logger.error(f"Login error: {str(e)}")
        return {'error': 'Login failed'}, 500

@auth_bp.route('/refresh', methods=['POST'])
@jwt_required(refresh=True)
def refresh():
    """Refresh access token"""
    try:
        current_user_id = int(get_jwt_identity())
        user = User.query.get(current_user_id)

        if not user or not user.is_active:
            return {'error': 'User not found or inactive'}, 401

        new_token = create_access_token(
            identity=current_user_id,
            expires_delta=timedelta(hours=24)
        )

        return {
            'access_token': new_token,
            'user': user.to_dict()
        }

    except Exception as e:
        current_app.logger.error(f"Token refresh error: {str(e)}")
        return {'error': 'Token refresh failed'}, 500

@auth_bp.route('/profile', methods=['GET'])
@jwt_required()
def get_profile():
    """Get current user profile"""
    try:
        user_id = int(get_jwt_identity())
        user = User.query.get(user_id)

        if not user:
            return {'error': 'User not found'}, 404

        return {'user': user.to_dict()}

    except Exception as e:
        current_app.logger.error(f"Get profile error: {str(e)}")
        return {'error': 'Failed to get profile'}, 500

@auth_bp.route('/profile', methods=['PUT'])
@jwt_required()
def update_profile():
    """Update user profile"""
    try:
        user_id = int(get_jwt_identity())
        user = User.query.get(user_id)

        if not user:
            return {'error': 'User not found'}, 404

        data = request.get_json()

        # Update allowed fields
        allowed_fields = ['first_name', 'last_name', 'organization', 'role']
        for field in allowed_fields:
            if field in data:
                setattr(user, field, data[field].strip() if data[field] else '')

        db.session.commit()

        return {
            'message': 'Profile updated successfully',
            'user': user.to_dict()
        }

    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Update profile error: {str(e)}")
        return {'error': 'Failed to update profile'}, 500

@auth_bp.route('/change-password', methods=['POST'])
@jwt_required()
def change_password():
    """Change user password"""
    try:
        user_id = int(get_jwt_identity())
        user = User.query.get(user_id)

        if not user:
            return {'error': 'User not found'}, 404

        data = request.get_json()
        current_password = data.get('current_password', '')
        new_password = data.get('new_password', '')

        if not current_password or not new_password:
            return {'error': 'Current and new passwords are required'}, 400

        # Verify current password
        if not user.check_password(current_password):
            return {'error': 'Current password is incorrect'}, 400

        # Validate new password
        is_valid, message = validate_password(new_password)
        if not is_valid:
            return {'error': message}, 400

        # Update password
        user.set_password(new_password)
        db.session.commit()

        return {'message': 'Password changed successfully'}

    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Change password error: {str(e)}")
        return {'error': 'Failed to change password'}, 500

@auth_bp.route('/verify', methods=['GET'])
@jwt_required()
def verify_token():
    """Verify JWT token validity"""
    try:
        user_id = int(get_jwt_identity())
        user = User.query.get(user_id)

        if not user or not user.is_active:
            return {'error': 'Invalid token'}, 401

        return {
            'valid': True,
            'user': user.to_dict()
        }

    except Exception as e:
        current_app.logger.error(f"Token verification error: {str(e)}")
        return {'error': 'Token verification failed'}, 500

@auth_bp.route('/logout', methods=['POST'])
@jwt_required()
def logout():
    """Logout user (client-side token removal)"""
    try:
        # In a production system, you might want to blacklist the token
        # For now, we just return a success message
        return {'message': 'Logged out successfully'}

    except Exception as e:
        current_app.logger.error(f"Logout error: {str(e)}")
        return {'error': 'Logout failed'}, 500

# Admin endpoints for user management
@auth_bp.route('/admin/users', methods=['GET'])
@jwt_required()
def admin_get_users():
    """Get all users (admin only)"""
    try:
        user_id = get_jwt_identity()
        admin_user = User.query.get(user_id)

        if not admin_user or admin_user.user_type != 'admin':
            return {'error': 'Admin access required'}, 403

        # Pagination
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)

        users = User.query.paginate(
            page=page,
            per_page=per_page,
            error_out=False
        )

        return {
            'users': [user.to_dict() for user in users.items],
            'pagination': {
                'page': page,
                'pages': users.pages,
                'per_page': per_page,
                'total': users.total
            }
        }

    except Exception as e:
        current_app.logger.error(f"Admin get users error: {str(e)}")
        return {'error': 'Failed to get users'}, 500

@auth_bp.route('/admin/users/<int:user_id>', methods=['PUT'])
@jwt_required()
def admin_update_user(user_id):
    """Update user (admin only)"""
    try:
        admin_user_id = get_jwt_identity()
        admin_user = User.query.get(admin_user_id)

        if not admin_user or admin_user.user_type != 'admin':
            return {'error': 'Admin access required'}, 403

        user = User.query.get(user_id)
        if not user:
            return {'error': 'User not found'}, 404

        data = request.get_json()

        # Update allowed fields
        allowed_fields = ['user_type', 'is_active', 'is_verified', 'organization', 'role']
        for field in allowed_fields:
            if field in data:
                setattr(user, field, data[field])

        db.session.commit()

        return {
            'message': 'User updated successfully',
            'user': user.to_dict()
        }

    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Admin update user error: {str(e)}")
        return {'error': 'Failed to update user'}, 500