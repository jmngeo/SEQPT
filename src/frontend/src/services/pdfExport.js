import jsPDF from 'jspdf'
import html2canvas from 'html2canvas'
import { ElMessage } from 'element-plus'

/**
 * PDF Export Service for SE-QPT Platform
 * Provides comprehensive PDF generation for various reports and documents
 */

class PDFExportService {
  constructor() {
    this.pdf = null
    this.pageWidth = 210 // A4 width in mm
    this.pageHeight = 297 // A4 height in mm
    this.margin = 20
    this.currentY = this.margin
    this.lineHeight = 7
    this.colors = {
      primary: '#667eea',
      secondary: '#764ba2',
      text: '#2c3e50',
      lightText: '#7f8c8d',
      success: '#67c23a',
      warning: '#e6a23c',
      danger: '#f56c6c'
    }
  }

  /**
   * Initialize new PDF document
   */
  initDocument() {
    this.pdf = new jsPDF('p', 'mm', 'a4')
    this.currentY = this.margin
    return this.pdf
  }

  /**
   * Add header to the document
   */
  addHeader(title, subtitle = '', includeDate = true) {
    // Header background
    this.pdf.setFillColor(102, 126, 234) // Primary color
    this.pdf.rect(0, 0, this.pageWidth, 25, 'F')

    // SE-QPT Logo/Title
    this.pdf.setTextColor(255, 255, 255)
    this.pdf.setFontSize(20)
    this.pdf.setFont('helvetica', 'bold')
    this.pdf.text('SE-QPT Platform', this.margin, 12)

    // Document title
    this.pdf.setFontSize(16)
    this.pdf.setFont('helvetica', 'normal')
    this.pdf.text(title, this.margin, 20)

    // Subtitle and date
    if (subtitle || includeDate) {
      this.pdf.setFontSize(10)
      this.pdf.setTextColor(240, 240, 240)

      if (subtitle) {
        this.pdf.text(subtitle, this.margin, 23)
      }

      if (includeDate) {
        const date = new Date().toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        })
        const dateWidth = this.pdf.getTextWidth(date)
        this.pdf.text(date, this.pageWidth - this.margin - dateWidth, 15)
      }
    }

    this.currentY = 35
    this.pdf.setTextColor(44, 62, 80) // Reset to default text color
  }

  /**
   * Add footer to the document
   */
  addFooter(pageNumber, totalPages = null) {
    const footerY = this.pageHeight - 15

    // Footer line
    this.pdf.setDrawColor(230, 230, 230)
    this.pdf.line(this.margin, footerY - 5, this.pageWidth - this.margin, footerY - 5)

    // Page number
    this.pdf.setFontSize(9)
    this.pdf.setTextColor(127, 140, 141)
    const pageText = totalPages ? `Page ${pageNumber} of ${totalPages}` : `Page ${pageNumber}`
    const pageWidth = this.pdf.getTextWidth(pageText)
    this.pdf.text(pageText, this.pageWidth - this.margin - pageWidth, footerY)

    // Generated by text
    this.pdf.text('Generated by SE-QPT Platform', this.margin, footerY)
  }

  /**
   * Add section title
   */
  addSectionTitle(title, fontSize = 14) {
    this.checkPageBreak(15)

    this.pdf.setFontSize(fontSize)
    this.pdf.setFont('helvetica', 'bold')
    this.pdf.setTextColor(102, 126, 234)
    this.pdf.text(title, this.margin, this.currentY)

    this.currentY += 10
    this.pdf.setFont('helvetica', 'normal')
    this.pdf.setTextColor(44, 62, 80)
  }

  /**
   * Add paragraph text
   */
  addParagraph(text, fontSize = 10, options = {}) {
    const { indent = 0, align = 'left', color = this.colors.text } = options

    this.pdf.setFontSize(fontSize)
    this.setColorFromHex(color)

    const maxWidth = this.pageWidth - 2 * this.margin - indent
    const lines = this.pdf.splitTextToSize(text, maxWidth)

    for (const line of lines) {
      this.checkPageBreak()

      let x = this.margin + indent
      if (align === 'center') {
        x = (this.pageWidth - this.pdf.getTextWidth(line)) / 2
      } else if (align === 'right') {
        x = this.pageWidth - this.margin - this.pdf.getTextWidth(line)
      }

      this.pdf.text(line, x, this.currentY)
      this.currentY += this.lineHeight
    }

    this.currentY += 3 // Extra spacing after paragraph
  }

  /**
   * Add table to the document
   */
  addTable(headers, data, options = {}) {
    const {
      columnWidths = null,
      headerColor = this.colors.primary,
      alternateRowColor = '#f8f9fa',
      fontSize = 9
    } = options

    this.checkPageBreak(20)

    const tableWidth = this.pageWidth - 2 * this.margin
    const numColumns = headers.length
    const colWidths = columnWidths || new Array(numColumns).fill(tableWidth / numColumns)

    let currentX = this.margin
    const startY = this.currentY

    // Table headers
    this.pdf.setFillColor(...this.hexToRgb(headerColor))
    this.pdf.rect(this.margin, this.currentY - 5, tableWidth, 10, 'F')

    this.pdf.setFontSize(fontSize)
    this.pdf.setFont('helvetica', 'bold')
    this.pdf.setTextColor(255, 255, 255)

    headers.forEach((header, index) => {
      this.pdf.text(header, currentX + 2, this.currentY)
      currentX += colWidths[index]
    })

    this.currentY += 8
    this.pdf.setFont('helvetica', 'normal')
    this.pdf.setTextColor(44, 62, 80)

    // Table data
    data.forEach((row, rowIndex) => {
      this.checkPageBreak(8)

      // Alternate row background
      if (rowIndex % 2 === 1) {
        this.pdf.setFillColor(...this.hexToRgb(alternateRowColor))
        this.pdf.rect(this.margin, this.currentY - 5, tableWidth, 8, 'F')
      }

      currentX = this.margin
      row.forEach((cell, colIndex) => {
        const cellText = String(cell || '')
        const maxCellWidth = colWidths[colIndex] - 4
        const lines = this.pdf.splitTextToSize(cellText, maxCellWidth)
        this.pdf.text(lines[0] || '', currentX + 2, this.currentY)
        currentX += colWidths[colIndex]
      })

      this.currentY += 8
    })

    // Table border
    this.pdf.setDrawColor(200, 200, 200)
    this.pdf.rect(this.margin, startY - 5, tableWidth, this.currentY - startY)

    this.currentY += 5
  }

  /**
   * Add chart image to PDF
   */
  async addChart(chartElement, title = '', width = 160, height = 100) {
    try {
      this.checkPageBreak(height + 20)

      if (title) {
        this.addSectionTitle(title, 12)
      }

      const canvas = await html2canvas(chartElement, {
        backgroundColor: '#ffffff',
        scale: 2
      })

      const imgData = canvas.toDataURL('image/png')
      const x = (this.pageWidth - width) / 2 // Center the chart

      this.pdf.addImage(imgData, 'PNG', x, this.currentY, width, height)
      this.currentY += height + 10

    } catch (error) {
      console.error('Error adding chart to PDF:', error)
      this.addParagraph(`[Chart: ${title || 'Visualization'} - Error loading image]`, 10, {
        color: this.colors.danger,
        align: 'center'
      })
    }
  }

  /**
   * Add assessment results summary
   */
  addAssessmentSummary(assessment) {
    this.addSectionTitle('Assessment Summary')

    // Basic info
    this.addParagraph(`Assessment: ${assessment.title}`, 12, { color: this.colors.primary })
    this.addParagraph(`Completed: ${new Date(assessment.completedAt).toLocaleDateString()}`)
    this.addParagraph(`Duration: ${assessment.duration} minutes`)
    this.addParagraph(`Score: ${assessment.score}%`, 11, {
      color: assessment.score >= 80 ? this.colors.success :
             assessment.score >= 60 ? this.colors.warning : this.colors.danger
    })

    this.currentY += 5

    // Competency breakdown
    if (assessment.competencyResults) {
      this.addSectionTitle('Competency Breakdown', 12)

      const headers = ['Competency', 'Score', 'Level', 'Status']
      const data = assessment.competencyResults.map(comp => [
        comp.name,
        `${comp.score}%`,
        `Level ${comp.level}`,
        comp.passed ? 'Passed' : 'Needs Improvement'
      ])

      this.addTable(headers, data, {
        columnWidths: [70, 25, 25, 40],
        fontSize: 9
      })
    }
  }

  /**
   * Add qualification plan overview
   */
  addQualificationPlan(plan) {
    this.addSectionTitle('Qualification Plan Overview')

    // Plan details
    this.addParagraph(`Plan Name: ${plan.name}`, 12, { color: this.colors.primary })
    this.addParagraph(`Target Role: ${plan.targetRole}`)
    this.addParagraph(`Created: ${new Date(plan.createdAt).toLocaleDateString()}`)
    this.addParagraph(`Status: ${plan.status}`)

    if (plan.description) {
      this.currentY += 5
      this.addParagraph('Description:', 11, { color: this.colors.text })
      this.addParagraph(plan.description, 10, { indent: 5 })
    }

    // Learning objectives
    if (plan.learningObjectives && plan.learningObjectives.length > 0) {
      this.addSectionTitle('Learning Objectives', 12)

      plan.learningObjectives.forEach((objective, index) => {
        this.addParagraph(`${index + 1}. ${objective.text}`, 10, { indent: 5 })
        if (objective.smartScore) {
          this.addParagraph(`   SMART Score: ${objective.smartScore}%`, 9, {
            color: this.colors.lightText,
            indent: 5
          })
        }
        this.currentY += 2
      })
    }

    // Training modules
    if (plan.modules && plan.modules.length > 0) {
      this.addSectionTitle('Training Modules', 12)

      const headers = ['Module', 'Duration', 'Format', 'Priority']
      const data = plan.modules.map(module => [
        module.title,
        `${module.duration} days`,
        module.format,
        module.priority
      ])

      this.addTable(headers, data, {
        columnWidths: [80, 30, 30, 30],
        fontSize: 9
      })
    }
  }

  /**
   * Add RAG objectives report
   */
  addRAGObjectivesReport(objectives, context) {
    this.addSectionTitle('RAG-LLM Generated Objectives Report')

    // Context information
    if (context) {
      this.addParagraph('Generation Context:', 11, { color: this.colors.primary })
      this.addParagraph(`Company: ${context.company}`, 10, { indent: 5 })
      this.addParagraph(`Department: ${context.department}`, 10, { indent: 5 })
      this.addParagraph(`Project Type: ${context.projectType}`, 10, { indent: 5 })
      this.addParagraph(`Target Role: ${context.targetRole}`, 10, { indent: 5 })
      this.currentY += 5
    }

    // Objectives summary
    const validatedCount = objectives.filter(obj => obj.validated).length
    const avgSmartScore = objectives.reduce((sum, obj) => sum + obj.smartScore, 0) / objectives.length

    this.addParagraph('Summary:', 11, { color: this.colors.primary })
    this.addParagraph(`Total Objectives: ${objectives.length}`, 10, { indent: 5 })
    this.addParagraph(`Validated: ${validatedCount}`, 10, { indent: 5 })
    this.addParagraph(`Average SMART Score: ${Math.round(avgSmartScore)}%`, 10, { indent: 5 })

    this.currentY += 5

    // Individual objectives
    this.addSectionTitle('Generated Objectives', 12)

    objectives.forEach((objective, index) => {
      this.checkPageBreak(25)

      this.addParagraph(`Objective ${index + 1}:`, 11, { color: this.colors.primary })
      this.addParagraph(objective.text, 10, { indent: 5 })

      // SMART Analysis
      if (objective.smartAnalysis) {
        this.addParagraph('SMART Analysis:', 10, {
          color: this.colors.lightText,
          indent: 5
        })

        objective.smartAnalysis.forEach(criterion => {
          this.addParagraph(`• ${criterion.name}: ${criterion.score}%`, 9, {
            indent: 10,
            color: criterion.score >= 80 ? this.colors.success :
                   criterion.score >= 60 ? this.colors.warning : this.colors.danger
          })
        })
      }

      this.addParagraph(`Overall SMART Score: ${objective.smartScore}%`, 10, {
        indent: 5,
        color: objective.smartScore >= 85 ? this.colors.success :
               objective.smartScore >= 70 ? this.colors.warning : this.colors.danger
      })

      if (objective.validated) {
        this.addParagraph('✓ Validated', 9, {
          indent: 5,
          color: this.colors.success
        })
      }

      this.currentY += 8
    })
  }

  /**
   * Add analytics report
   */
  addAnalyticsReport(analytics, charts = []) {
    this.addSectionTitle('Analytics Report')

    // Overview metrics
    if (analytics.overview) {
      this.addSectionTitle('Key Metrics', 12)

      const metrics = [
        ['Total Assessments', analytics.overview.totalAssessments],
        ['Active Users', analytics.overview.activeUsers],
        ['Average Score', `${analytics.overview.averageScore}%`],
        ['Completion Rate', `${analytics.overview.completionRate}%`]
      ]

      this.addTable(['Metric', 'Value'], metrics, {
        columnWidths: [100, 50],
        fontSize: 10
      })
    }

    // Performance insights
    if (analytics.insights) {
      this.addSectionTitle('Key Insights', 12)

      analytics.insights.forEach(insight => {
        this.addParagraph(`• ${insight}`, 10, { indent: 5 })
      })

      this.currentY += 5
    }

    // Add charts if provided
    for (const chart of charts) {
      if (chart.element && chart.title) {
        await this.addChart(chart.element, chart.title, chart.width, chart.height)
      }
    }

    // Top performers
    if (analytics.topPerformers) {
      this.addSectionTitle('Top Performers', 12)

      const headers = ['Rank', 'Name', 'Role', 'Score', 'Assessments']
      const data = analytics.topPerformers.map(performer => [
        performer.rank,
        performer.name,
        performer.role,
        `${performer.score}%`,
        performer.assessments
      ])

      this.addTable(headers, data, {
        columnWidths: [20, 50, 50, 30, 30],
        fontSize: 9
      })
    }
  }

  /**
   * Utility methods
   */
  checkPageBreak(requiredSpace = 20) {
    if (this.currentY + requiredSpace > this.pageHeight - 30) {
      this.pdf.addPage()
      this.currentY = this.margin
    }
  }

  setColorFromHex(hex) {
    const rgb = this.hexToRgb(hex)
    this.pdf.setTextColor(...rgb)
  }

  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    return result ? [
      parseInt(result[1], 16),
      parseInt(result[2], 16),
      parseInt(result[3], 16)
    ] : [0, 0, 0]
  }

  /**
   * Save PDF with filename
   */
  save(filename = 'se-qpt-report.pdf') {
    try {
      // Add page numbers to all pages
      const totalPages = this.pdf.internal.getNumberOfPages()
      for (let i = 1; i <= totalPages; i++) {
        this.pdf.setPage(i)
        this.addFooter(i, totalPages)
      }

      this.pdf.save(filename)
      ElMessage.success('PDF exported successfully')
    } catch (error) {
      console.error('Error saving PDF:', error)
      ElMessage.error('Failed to export PDF')
      throw error
    }
  }

  /**
   * Get PDF as blob for further processing
   */
  getBlob() {
    return this.pdf.output('blob')
  }

  /**
   * Get PDF as data URL
   */
  getDataURL() {
    return this.pdf.output('dataurlstring')
  }
}

// Export factory methods for common report types
export const PDFExport = {
  /**
   * Export assessment results
   */
  async exportAssessment(assessment, options = {}) {
    const exporter = new PDFExportService()
    exporter.initDocument()

    exporter.addHeader(
      'Assessment Report',
      `${assessment.title} - ${assessment.user?.name || 'User'}`
    )

    exporter.addAssessmentSummary(assessment)

    if (options.includeCharts && options.charts) {
      for (const chart of options.charts) {
        await exporter.addChart(chart.element, chart.title)
      }
    }

    const filename = options.filename || `assessment-${assessment.id}-${Date.now()}.pdf`
    exporter.save(filename)

    return exporter
  },

  /**
   * Export qualification plan
   */
  async exportQualificationPlan(plan, options = {}) {
    const exporter = new PDFExportService()
    exporter.initDocument()

    exporter.addHeader(
      'Qualification Plan',
      `${plan.name} - ${plan.user?.name || 'User'}`
    )

    exporter.addQualificationPlan(plan)

    if (options.includeProgress && plan.progressData) {
      exporter.addSectionTitle('Progress Overview', 12)
      // Add progress visualization here
    }

    const filename = options.filename || `qualification-plan-${plan.id}-${Date.now()}.pdf`
    exporter.save(filename)

    return exporter
  },

  /**
   * Export RAG objectives report
   */
  async exportRAGObjectives(objectives, context, options = {}) {
    const exporter = new PDFExportService()
    exporter.initDocument()

    exporter.addHeader(
      'RAG-LLM Objectives Report',
      `Generated on ${new Date().toLocaleDateString()}`
    )

    exporter.addRAGObjectivesReport(objectives, context)

    const filename = options.filename || `rag-objectives-${Date.now()}.pdf`
    exporter.save(filename)

    return exporter
  },

  /**
   * Export analytics report
   */
  async exportAnalytics(analyticsData, options = {}) {
    const exporter = new PDFExportService()
    exporter.initDocument()

    const { startDate, endDate } = options.dateRange || {}
    const subtitle = startDate && endDate
      ? `Period: ${startDate} to ${endDate}`
      : 'All Time'

    exporter.addHeader('Analytics Report', subtitle)

    await exporter.addAnalyticsReport(analyticsData, options.charts || [])

    const filename = options.filename || `analytics-report-${Date.now()}.pdf`
    exporter.save(filename)

    return exporter
  },

  /**
   * Create custom report
   */
  createCustomReport(title, subtitle = '') {
    const exporter = new PDFExportService()
    exporter.initDocument()
    exporter.addHeader(title, subtitle)
    return exporter
  }
}

export default PDFExportService